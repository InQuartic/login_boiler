"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_1 = require("graphql");
const util_1 = require("@gql2ts/util");
const language_typescript_1 = require("@gql2ts/language-typescript");
const dedent = require("dedent");
const run = (schemaInput, optionsInput) => {
    const { generateEnumName, generateInterfaceName, generateTypeName, printType, formatInput, wrapList, formatEnum, typeBuilder, generateInterfaceDeclaration: gID, interfaceBuilder, addSemicolon, enumTypeBuilder, generateDocumentation, typeMap } = optionsInput.formats;
    const TYPE_MAP = Object.assign({}, language_typescript_1.DEFAULT_TYPE_MAP, (typeMap || {}), (optionsInput.typeMap || {}));
    const generateRootDataName = schema => {
        let rootNamespaces = [];
        const queryType = schema.getQueryType();
        const mutationType = schema.getMutationType();
        const subscriptionType = schema.getSubscriptionType();
        if (queryType) {
            rootNamespaces.push(generateInterfaceName(queryType.name));
        }
        if (mutationType) {
            rootNamespaces.push(generateInterfaceName(mutationType.name));
        }
        if (subscriptionType) {
            rootNamespaces.push(generateInterfaceName(subscriptionType.name));
        }
        return util_1.filterAndJoinArray(rootNamespaces, ' | ');
    };
    const generateRootTypes = schema => util_1.filterAndJoinArray([
        interfaceBuilder(generateInterfaceName('GraphQLResponseRoot'), gID([
            formatInput('data', !optionsInput.legacy, generateRootDataName(schema)),
            formatInput('errors', !optionsInput.legacy, wrapList(generateInterfaceName('GraphQLResponseError')))
        ])),
        interfaceBuilder(generateInterfaceName('GraphQLResponseError'), gID([
            '/** Required for all errors */',
            formatInput('message', false, TYPE_MAP.String),
            formatInput('locations', !optionsInput.legacy, wrapList(generateInterfaceName('GraphQLResponseErrorLocation'))),
            `/** 7.2.2 says 'GraphQL servers may provide additional entries to error' */`,
            formatInput('[propName: string]', false, TYPE_MAP.__DEFAULT),
        ])),
        interfaceBuilder(generateInterfaceName('GraphQLResponseErrorLocation'), gID([
            formatInput('line', false, TYPE_MAP.Int),
            formatInput('column', false, TYPE_MAP.Int),
        ]))
    ], '\n\n');
    const wrapWithDocumentation = (declaration, documentation) => dedent `
    ${generateDocumentation(documentation)}
    ${declaration}
  `;
    function isInputField(field) {
        return (!!field.astNode && field.astNode.kind === 'InputValueDefinition') || !({}).hasOwnProperty.call(field, 'args');
    }
    const generateTypeDeclaration = (description, name, possibleTypes) => wrapWithDocumentation(addSemicolon(typeBuilder(name, possibleTypes)), { description, tags: [] }) + '\n\n';
    const typeNameDeclaration = name => addSemicolon(`__typename: "${name}"`);
    const generateInterfaceDeclaration = ({ name, description }, declaration, fields, additionalInfo, isInput) => {
        if (!isInput && !optionsInput.ignoreTypeNameDeclaration) {
            fields = [typeNameDeclaration(name), ...fields];
        }
        return additionalInfo + wrapWithDocumentation(interfaceBuilder(declaration, gID(fields)), { description, tags: [] });
    };
    const generateEnumDeclaration = (description, name, enumValues) => {
        if (!enumTypeBuilder) {
            console.warn('Missing `enumTypeBuilder` from language file and falling back to using a type for enums. This new option was added in v1.5.0');
        }
        return wrapWithDocumentation((enumTypeBuilder || typeBuilder)(generateEnumName(name), addSemicolon(formatEnum(enumValues, generateDocumentation))), { description, tags: [] });
    };
    /**
     * TODO
     * - add support for custom types (via optional json file or something)
     * - allow this to return metadata for Non Null types
     */
    const resolveInterfaceName = type => {
        if (util_1.isList(type)) {
            return wrapList(resolveInterfaceName((type).ofType));
        }
        else if (util_1.isNonNullable(type)) {
            return `!${resolveInterfaceName((type).ofType)}`;
        }
        else if (util_1.isScalar(type)) {
            return TYPE_MAP[type.name] || TYPE_MAP.__DEFAULT;
        }
        else if (graphql_1.isAbstractType(type)) {
            return generateTypeName(type.name);
        }
        else if (util_1.isEnum(type)) {
            return generateEnumName(type.name);
        }
        else {
            return generateInterfaceName(type.name);
        }
    };
    const extractInterfaceMetadata = (interfaceName, supportsNullability) => {
        const isNonNull = interfaceName.includes('!');
        return {
            isNonNull,
            name: interfaceName.replace(/\!/g, ''),
            showNullabilityAttribute: !isNonNull && supportsNullability
        };
    };
    const fieldToDefinition = (field, isInput, supportsNullability) => {
        const { name, showNullabilityAttribute, isNonNull } = extractInterfaceMetadata(resolveInterfaceName(field.type), supportsNullability);
        return formatInput(field.name, isInput && !isNonNull, printType(name, !showNullabilityAttribute));
    };
    const generateArgumentDeclaration = (arg, supportsNullability) => {
        const { name, isNonNull, showNullabilityAttribute } = extractInterfaceMetadata(resolveInterfaceName(arg.type), supportsNullability);
        return util_1.filterAndJoinArray([
            generateDocumentation(util_1.buildDocumentation(arg)),
            formatInput(arg.name, !isNonNull, printType(name, !showNullabilityAttribute))
        ]);
    };
    const generateArgumentsDeclaration = (field, parentName, supportsNullability) => {
        if (isInputField(field) || !field.args || !field.args.length) {
            return null;
        }
        const fieldDeclaration = field.args.map(arg => generateArgumentDeclaration(arg, supportsNullability));
        const name = generateInterfaceName(`${field.name}_On_${parentName}`) + 'Arguments';
        return interfaceBuilder(name, gID(fieldDeclaration));
    };
    const findRootType = type => {
        if (util_1.isList(type) || util_1.isNonNullable(type)) {
            return findRootType(type.ofType);
        }
        return type;
    };
    const filterField = (field, ignoredTypes) => {
        let nestedType = findRootType(field.type);
        return !ignoredTypes.has(nestedType.name) && (!optionsInput.excludeDeprecatedFields || !field.isDeprecated);
    };
    const generateAbstractTypeDeclaration = (type, ignoredTypes) => {
        const poss = schemaInput.getPossibleTypes(type);
        let possibleTypes = poss
            .filter(t => !ignoredTypes.has(t.name))
            .map(t => generateInterfaceName(t.name));
        return generateTypeDeclaration(type.description, generateTypeName(type.name), possibleTypes.join(' | '));
    };
    const typeToInterface = (type, ignoredTypes, supportsNullability) => {
        if (util_1.isScalar(type)) {
            return null;
        }
        if (util_1.isUnion(type)) {
            return generateAbstractTypeDeclaration(type, ignoredTypes);
        }
        if (util_1.isEnum(type)) {
            return generateEnumDeclaration(type.description, type.name, type.getValues());
        }
        const isInput = type instanceof graphql_1.GraphQLInputObjectType;
        const f1 = type.getFields();
        const f = Object.keys(f1).map(k => f1[k]);
        const filteredFields = f.filter(field => filterField(field, ignoredTypes));
        const fields = filteredFields
            .map(field => [generateDocumentation(util_1.buildDocumentation(field)), fieldToDefinition(field, isInput, supportsNullability)])
            .reduce((acc, val) => [...acc, ...val], [])
            .filter(Boolean);
        const interfaceDeclaration = generateInterfaceName(type.name);
        let additionalInfo = '';
        if (graphql_1.isAbstractType(type)) {
            additionalInfo = generateAbstractTypeDeclaration(type, ignoredTypes);
        }
        return util_1.filterAndJoinArray([
            generateInterfaceDeclaration(type, interfaceDeclaration, fields, additionalInfo, isInput),
            ...filteredFields.map(field => generateArgumentsDeclaration(field, type.name, supportsNullability))
        ], '\n\n');
    };
    const typesToInterfaces = (schema, options) => {
        const ignoredTypes = new Set(options.ignoredTypes);
        const supportsNullability = !options.legacy;
        const types = schema.getTypeMap();
        const typeArr = Object.keys(types).map(k => types[k]);
        const typeInterfaces = typeArr
            .filter(type => !type.name.startsWith('__')) // remove introspection types
            .filter(type => // remove ignored types
         !ignoredTypes.has(type.name))
            .map(type => // convert to interface
         typeToInterface(type, ignoredTypes, supportsNullability));
        return util_1.filterAndJoinArray([
            generateRootTypes(schema),
            ...typeInterfaces
        ], '\n\n');
    };
    return typesToInterfaces(schemaInput, optionsInput);
};
exports.schemaToInterfaces = (schema, options = {}, formatters = {}) => run(util_1.schemaFromInputs(schema), Object.assign({}, options, { formats: Object.assign({}, language_typescript_1.DEFAULT_OPTIONS, formatters) }));
exports.generateNamespace = (namespace, schema, options = {}, overrides = {}) => {
    const formatters = Object.assign({}, language_typescript_1.DEFAULT_OPTIONS, overrides);
    return formatters.postProcessor(formatters.generateNamespace(namespace, exports.schemaToInterfaces(schema, options, formatters)));
};
//# sourceMappingURL=index.js.map